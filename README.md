# 数独实验报告

![数独软件界面](https://raw.githubusercontent.com/mlzeng/Sudoku/master/Screenshot.png "数独软件界面")

## 实验要求
+ 实现一个带图形界面的数独游戏

## 实验环境

+ OS: Arch Linux 
+ Kernel: x86\_64 Linux 4.10.13-1-ARCH
+ CPU: Intel Core i7-4710MQ @ 8x 3.5GHz

## 实验工具
+ GCC 6.3.1 
+ SWIG 3.0.12
+ Python 3.6.1

## 实现思路
数独软件包含主操作界面、数独求解/生成模块、数独题目编辑器等。

用户界面设计遵循less is more的极简主义设计哲学（易于上手，不需要教程也可方便地使用）。

## 具体实现
### 用户界面
图形界面使用Python-Tkinter编写。

程序运行时有两种模式：Play mode和Edit mode，可以通过点击按钮来切换。

可以纯键盘操作，也可以纯鼠标操作，键盘和鼠标混用也可以很好地操作。

### 数独题目求解
该软件的求解模块使用DLX（Dancing Links X）算法实现，可以判断给定的题目是否有解，若有解则给出答案，并判断是否是唯一解。

本程序利用数独的特性对其DLX算法实现进行了针对性的优化（例如加入了启发式方法，优先搜索最有可能对应正确答案的结点），运行速度极快，对于最难的题目，求解时间均在10毫秒以内。若使用朴素DFS算法求解这些题目，则往往需要10秒以上，甚至会在某些构造的提示数很少的无解局面下长期运行不出结果（长时间找不到解却又无法证明无解）。

以下是我构造出来的能够卡住朴素DFS算法的无解局面（假设算法从第一行第一列开始搜索）：
> 0 0 0 0 0 0 0 0 0
>
> 0 0 0 0 0 0 2 0 0
>
> 0 0 0 0 0 0 1 0 0
>
> 0 0 0 0 0 0 0 0 0
>
> 0 0 0 0 0 0 0 2 0
>
> 0 0 0 0 0 0 0 1 0
>
> 0 2 1 0 0 0 0 0 0
>
> 0 0 0 0 2 1 0 0 0
>
> 0 0 0 0 0 0 0 0 0

为了使求解模块的运行速度尽量快，该模块由C语言编写实现，并使用了gcc的-O3编译优化选项进行编译。

为了使求解模块方便地与主程序（Python实现）通信，该模块由SWIG（Simplified Wrapper and Interface Generator）打包成可以被Python直接调用的模块（\_DLX.so）。

### 估计数独难度
首先，数独的难度和提示数的个数并没有直接的关系。科学家已经证明，合法的数独题目最少要给出17个提示数，然而，只有17个提示数的题目却完全可以是一道基础题（只用最基本的技巧就可以求解）：

> 0 0 0 0 0 6 0 0 0
>
> 4 5 0 0 0 0 1 0 0
>
> 0 0 0 0 0 2 5 0 0
>
> 0 7 0 0 1 0 0 0 0
>
> 0 0 0 0 0 0 0 0 6
>
> 8 0 0 0 0 0 0 7 2
>
> 0 0 0 0 4 8 9 0 0
>
> 0 1 2 0 0 0 0 0 0

利用搜索算法运行的时间来判断难度是完全可行的，但如果搜索算法用的是朴素DFS算法，就会非常不准确。用朴素DFS算法求解上面给出的基础题时需要的时间甚至比一些提示数多的难题更长，导致上面的基础题被误判为难题。而且，朴素DFS算法的搜索顺序是与位置相关的，若将数独题目方阵旋转或者转置，也会导致估计出的难度值发生很大变化，这显然是不科学的。

若沿用上述方法，并将朴素DFS算法换成强大的DLX算法，则难度估计的准确度和科学性会有很大提升。这是因为DLX算法解数独的过程类似于人类解数独的过程，带有一定的启发式特性：先填上“可以确定”的数，若没有“可以确定”的数，则先猜测“最有希望”的数。故DLX算法运行的时间可以反映出该题目对于人类求解的困难程度，直接将DLX算法总共搜索的结点数作为难度值即可。（人类发明了很多特殊的技巧来求解数独题目，该难度判断方法无法反映出这些技巧的难度，但经过测试，该方法给出的难度估计与实际情况下人类求解的难度基本一致）

### 数独题目生成
该软件的数独题目生成部分采用了Monte-Carlo方法。先随机生成一个满足每行每列每九宫格均包含1~9的数字方阵，从中随机挖去一个数，使用求解器进行判断，若数独仍为唯一解，则重复该过程，否则撤销挖去操作，并尝试挖去另一个数。重复以上过程，直到挖去方阵中任何一个数都会导致多解时，停止以上过程，此时该方阵就是一个合法的数独题目（必定只有唯一解）。

使用上述过程生成的数独题目难度不一，但具有良好的难度概率分布特性，故可以先大量随机生成数独题目，对它们进行难度判断，再从中选取一个难度最接近需求的题目。这种方法可以比较稳定地产生指定难度的数独题目，同时足以产生极高难度（extreme）的数独题目。（求解模块的极致的求解速度使得这种方法成为可能）

数独题目生成过程需频繁调用求解过程，由于Python的IO速度很慢，若使用主程序调用求解模块将导致整个过程运行速度大幅下降，故将数独题目生成程序和数独求解程序打包进同一个模块中，使求解模块同时具有题目生成功能，主程序只需一次模块调用即可得到题目。这样做显著提升了软件的运行速度。

## 使用方法
使用前请确保本机安装了以下软件包：
+ GCC
+ SWIG
+ Python3
+ Python3-Tkinter

运行make.sh编译生成数独求解模块\_DLX.so。

运行testDLX.py，用各大数独网站数据库收集的最高难度的数独题目（Hardest.txt）对数独求解模块进行测试。

运行Sudoku.py，启动数独软件。

### 按钮作用解释：

Play:切换至Play mode（不可编辑题目）

Edit:切换至Edit mode（可编辑题目）

Solve:求解当前局面（若有解则填入紫色数字）

Generate:生成新题目（题目提示数为黑色）

Clear:清除所有非提示数（若只有提示数则全部清除）

Destroy:清除所有数字和历史记录

Quit:保存历史记录并退出程序

### 纯鼠标操作方法：
+ 在Play mode时：

在方格上点击左键：填入确定的数字（蓝色）

在方格上点击右键：清除已填入的数字（不可以清除题目提示数）

在方格上点击中键：填入猜测的数字（绿色）

+ 在Edit mode时：

在方格上点击左键：填入题目提示数（黑色）

在方格上点击右键：清除数字

在方格上点击中键：同左键

+ 所有模式下：

在方格上滑动滚轮：增减待填入的数字

在消息框上滑动滚轮：访问历史记录（Undo/Redo）

在消息框上点击左右键：改变出题模块的出题难度（难度范围：0\~200）

### 纯键盘操作方法：
数字键1\~9：切换待填入数字至1\~9并且填入之

方向键：移动需要填入数字的位置

A（或Enter、Space）、D（或Backspace、Delete）键：填入/清除数字

X键：填入猜测的数字

W、S键：增减待填入的数字

Q、E键：访问历史记录

PageUp、PageDown键：改变出题难度

Shift+按钮名称首字母：等同于鼠标点击按钮

